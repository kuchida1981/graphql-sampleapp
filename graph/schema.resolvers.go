package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/kuchida1981/graphql-sampleapp/graph/model"
	"github.com/kuchida1981/graphql-sampleapp/internal/domain"
	"github.com/kuchida1981/graphql-sampleapp/internal/repository"
)

// Hello is the resolver for the hello field.
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello World", nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context) ([]*model.Message, error) {
	messages, err := r.messageRepo.List(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch messages: %w", err)
	}

	result := make([]*model.Message, len(messages))
	for i, msg := range messages {
		result[i] = &model.Message{
			ID:        msg.ID,
			Content:   msg.Content,
			Author:    msg.Author,
			CreatedAt: msg.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return result, nil
}

// Message is the resolver for the message field.
func (r *queryResolver) Message(ctx context.Context, id string) (*model.Message, error) {
	msg, err := r.messageRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch message: %w", err)
	}

	return &model.Message{
		ID:        msg.ID,
		Content:   msg.Content,
		Author:    msg.Author,
		CreatedAt: msg.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.userRepo.List(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	result := make([]*model.User, len(users))
	for i, user := range users {
		result[i] = &model.User{
			ID:        user.ID,
			Name:      user.Name,
			Email:     user.Email,
			CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := r.userRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}

	return &model.User{
		ID:        user.ID,
		Name:      user.Name,
		Email:     user.Email,
		CreatedAt: user.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// WeatherAlerts is the resolver for the weatherAlerts field.
func (r *queryResolver) WeatherAlerts(ctx context.Context, region *string, issuedAfter *string) ([]*model.WeatherAlert, error) {
	log.Printf("WeatherAlerts resolver called with region=%v, issuedAfter=%v", region, issuedAfter)

	filter := repository.MetadataFilter{
		Region: region,
	}

	if issuedAfter != nil {
		parsedTime, err := time.Parse(time.RFC3339, *issuedAfter)
		if err != nil {
			log.Printf("WeatherAlerts: Failed to parse issuedAfter: %v", err)
			return nil, fmt.Errorf("invalid issuedAfter format, expected ISO8601: %w", err)
		}
		filter.IssuedAfter = &parsedTime
	}

	metadataList, err := r.weatherAlertMetadataRepo.Search(ctx, filter)
	if err != nil {
		log.Printf("WeatherAlerts: Failed to search metadata: %v", err)
		return nil, fmt.Errorf("failed to search weather alerts: %w", err)
	}

	log.Printf("WeatherAlerts: Found %d metadata records", len(metadataList))

	if len(metadataList) == 0 {
		return []*model.WeatherAlert{}, nil
	}

	ids := make([]string, len(metadataList))
	metadataMap := make(map[string]*domain.WeatherAlertMetadata)
	for i, metadata := range metadataList {
		ids[i] = metadata.ID
		metadataMap[metadata.ID] = metadata
	}

	weatherAlerts, err := r.weatherAlertRepo.GetByIDs(ctx, ids)
	if err != nil {
		log.Printf("WeatherAlerts: Failed to get weather alert details: %v", err)
		return nil, fmt.Errorf("failed to get weather alert details: %w", err)
	}

	log.Printf("WeatherAlerts: Retrieved %d weather alerts from Firestore", len(weatherAlerts))

	result := make([]*model.WeatherAlert, 0, len(weatherAlerts))
	for _, alert := range weatherAlerts {
		metadata, ok := metadataMap[alert.ID]
		if !ok {
			log.Printf("WeatherAlerts: Warning - metadata not found for %s (skipping)", alert.ID)
			continue
		}

		rawDataJSON, err := json.Marshal(alert.RawData)
		if err != nil {
			log.Printf("WeatherAlerts: Warning - failed to marshal rawData for %s: %v", alert.ID, err)
			rawDataJSON = []byte("{}")
		}

		result = append(result, &model.WeatherAlert{
			ID:              alert.ID,
			Region:          metadata.Region,
			Severity:        metadata.Severity,
			IssuedAt:        metadata.IssuedAt.Format("2006-01-02T15:04:05Z07:00"),
			Title:           alert.Title,
			Description:     alert.Description,
			RawData:         string(rawDataJSON),
			AffectedAreas:   alert.AffectedAreas,
			Recommendations: alert.Recommendations,
		})
	}

	log.Printf("WeatherAlerts: Returning %d weather alerts", len(result))
	return result, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
